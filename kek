#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cmath>
#include <cassert>
#include <random>
#include <fstream>
#include <chrono>
#include <set>
#include <queue>
#include <deque>
#include <unordered_set>
#include <set>
std::mt19937 mt_treap(228);

using IndexType = uint16_t;

struct TreapNode {
    TreapNode *left;
    TreapNode *right;
    TreapNode *parent;
    uint16_t val;
    uint16_t size;
    char rev;
    int32_t y;

    TreapNode() = default;

    inline void Push() {
        if (rev) {
            std::swap(left, right);
            if (left) {
                left->Reverse();
            }
            if (right) {
                right->Reverse();
            }
            rev = 0;
        }
    }

    TreapNode *&GetRight() {
        Push();
        return right;
    }

    TreapNode *&GetLeft() {
        Push();
        return left;
    }

    TreapNode(int v, TreapNode *l, TreapNode *r) : val(v), size{1}, rev{0}, y(mt_treap()), left(l), right(r),
                                                   parent(nullptr) {}

    void Reverse() {
        rev ^= 1;
    }

    static inline int Size(TreapNode *v) {
        return v ? v->size : 0;
    }

    static inline void Update(TreapNode *v) {
        if (!v) {
            return;
        }
        v->size = Size(v->GetRight()) + Size(v->GetLeft()) + 1;
        if (v->GetLeft()) {
            v->GetLeft()->parent = v;
        }
        if (v->GetRight()) {
            v->GetRight()->parent = v;
        }
        v->parent = nullptr;
    }

    bool IsReversed() const {
        return rev;
    }
};

struct FlippingArray {
    FlippingArray(const std::vector<IndexType> &values) : size_(values.size()) {
        values_.resize(size_);
        nodes_memory.resize(size_);
        for (auto &el : values) {
            AddNode(el);
        }
    }

    int Next(int val) {
        auto *ptr = values_[val];
        AccessNode(ptr);

        if (ptr->GetRight()) {
            return GoLeft(ptr->GetRight());
        } else {
            while (ptr->parent) {
                if (ptr->parent->GetLeft() == ptr) {
                    return ptr->parent->val;
                }
                ptr = ptr->parent;
            }
            return GetFirst();
        }
    }

    int Prev(int val) {
        auto *ptr = values_[val];
        AccessNode(ptr);

        if (ptr->GetLeft()) {
            return GoRight(ptr->GetLeft());
        } else {
            while (ptr->parent) {
                if (ptr->parent->GetRight() == ptr) {
                    return ptr->parent->val;
                }
                ptr = ptr->parent;
            }
            return GetLast();
        }
    }

    bool Reverse2Opt(int t1, int t2, int t3, int t4) {
        // assert(t2 == Next(t1) || t2 == Prev(t1));
        // assert(t4 == Next(t3) || t4 == Prev(t3));
        return ReverseIfNothingBetween(values_[t1], values_[t2], values_[t4], values_[t3]);
    }

    void ReverseBetweenValues(int vl, int vr, int k) {
        ReverseBetween(values_[vl], values_[vr], k);
    }

    void Commit() {
        what_have_done_.clear();
    }

    bool Empty() {
        return what_have_done_.empty();
    }

    void Revert() {
        if (what_have_done_.empty()) {
            return;
        }
        ReverseBetweenValues(what_have_done_.back().l_value, what_have_done_.back().r_value, what_have_done_.back().k);
        what_have_done_.pop_back();
    }

    struct Event {
        int l_value;
        int r_value;
        int k;
    };

    std::vector<IndexType> Traverse() {
        std::vector<IndexType> res;
        Dfs(root, res);
        return res;
    }
private:
    std::vector<Event> what_have_done_;

    static void AccessNode(TreapNode *node) {
        if (node->parent) {
            AccessNode(node->parent);
        }
        node->Push();
    }

    int GetFirst() {
        auto *ptr = root;
        while (ptr->GetLeft()) {
            ptr = ptr->GetLeft();
        }
        return ptr->val;
    }

    int GetLast() {
        auto *ptr = root;
        while (ptr->GetRight()) {
            ptr = ptr->GetRight();
        }
        return ptr->val;
    }

    int GoLeft(TreapNode *ptr) {
        assert(ptr);
        while (ptr->GetLeft()) {
            ptr = ptr->GetLeft();
        }
        return ptr->val;
    }

    int GoRight(TreapNode *ptr) {
        assert(ptr);
        while (ptr->GetRight()) {
            ptr = ptr->GetRight();
        }
        return ptr->val;
    }

    void ReverseBetween(TreapNode *l, TreapNode *r, int k) {
        if (l == r) {
            return;
        }
        if (k < 0) {
            std::swap(l, r);
        }
        auto li = FindOutIndex(l);
        auto ri = FindOutIndex(r);
        assert(li != ri);
        if (li < ri) {
            Split(root, li, hl, hr);
            Split(hr, ri - li + 1, hm1, hm2);
            assert(TreapNode::Size(hm1) == ri - li + 1);
            hm1->Reverse();
            root = Merge(Merge(hl, hm1), hm2);
        } else {
            std::swap(li, ri);
            Split(root, li + 1, hl, hr);
            if (li + 1 == ri) {
                hr->Reverse();
                hl->Reverse();
                root = Merge(hr, hl);
                return;
            }
            Split(hr, ri - li - 1, hm1, hm2);
            assert(TreapNode::Size(hm1) == ri - li - 1);
            hl->Reverse();
            hm2->Reverse();
            root = Merge(Merge(hm2, hm1), hl);
        }
    }

    bool ReverseIfNothingBetween(TreapNode *l, TreapNode *m1, TreapNode *m2, TreapNode *r) {
        auto li = FindOutIndex(l);
        auto m1i = FindOutIndex(m1);
        auto m2i = FindOutIndex(m2);
        auto ri = FindOutIndex(r);

        for (int k : {1, -1}) {
            if (k == -1) {
                std::swap(li, ri);
                std::swap(l, r);
            }

            auto in_segment = [&](int l, int m, int r) {
                return (l <= m && m <= r);
            };
            bool find_something = true;
            if (li <= ri) {
                find_something = in_segment(li, m1i, ri) || in_segment(li, m2i, ri);
            } else {
                find_something = (in_segment(0, m1i, ri) || in_segment(0, m2i, ri)) ||
                                 (in_segment(li, m1i, size_ - 1) || in_segment(li, m2i, size_ - 1));
            }
            if (!find_something) {
                what_have_done_.push_back({r->val, l->val, 1});
                ReverseBetween(l, r, 1);
                return true;
            }
        }
        return false;
    }

    void AddNode(int val) {
        TreapNode* cur = &nodes_memory[id++];
        *cur = TreapNode(val, nullptr, nullptr);
        if (!root) {
            root = cur;
        } else {
            root = Merge(root, cur);
        }
        values_[val] = cur;
    }

    static TreapNode *Merge(TreapNode *left, TreapNode *right) {
        if (!left) {
            return right;
        }
        if (!right) {
            return left;
        }
        if (left->y < right->y) {
            left->GetRight() = Merge(left->GetRight(), right);
            TreapNode::Update(left);
            return left;
        } else {
            right->GetLeft() = Merge(left, right->GetLeft());
            TreapNode::Update(right);
            return right;
        }
    }

    void Dfs(TreapNode* node, std::vector<IndexType>& answer) {
        if (!node)
            return;
        Dfs(node->GetLeft(), answer);
        answer.push_back(node->val);
        Dfs(node->GetRight(), answer);
    }



    static void Split(TreapNode *t, int k, TreapNode *&l, TreapNode *&r) {
        if (!t) {
            l = 0;
            r = 0;
            return;
        }
        if (!k) {
            l = nullptr;
            r = t;
            return;
        }
        auto cur_l_size = TreapNode::Size(t->GetLeft());
        if (cur_l_size >= k) {
            Split(t->GetLeft(), k, l, t->GetLeft());
            r = t;
        } else {
            Split(t->GetRight(), k - cur_l_size - 1, t->GetRight(), r);
            l = t;
        }
        TreapNode::Update(l);
        TreapNode::Update(r);
    }

    static int FindOutIndex(TreapNode *node) {
        AccessNode(node);
        assert(node);
        int to_the_left = TreapNode::Size(node->GetLeft()) + 1;

        while (node->parent) {
            if (node->parent->GetRight() == node) {
                to_the_left += 1 + TreapNode::Size(node->parent->GetLeft());
            }
            node = node->parent;
        }
        return to_the_left - 1;
    }

    int size_;
    TreapNode *hl, *hr, *hm1, *hm2;
    TreapNode *root{nullptr};
    std::vector<TreapNode *> values_;
    std::vector<TreapNode> nodes_memory;
    int id{0};
};

using IndexType = uint16_t;

struct Timer {
    void StartCPU() {
        prev_time_cpu = std::chrono::system_clock::now();
    }

    void FinishCPU() {
        all_time_cpu += std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::system_clock::now() - prev_time_cpu)
                .count();
    }

    void Reset() {
        all_time_cpu = 0;
    }

    double TimeInSec() {
        return all_time_cpu / 1e9;
    }

    long all_time_cpu = 0;
    std::chrono::time_point<std::chrono::system_clock> prev_time_cpu;
} timer;

struct Point {
    Point() = default;

    double Distance(const Point &point) const {
        return sqrt((x - point.x) * (x - point.x) + (y - point.y) * (y - point.y));
    }

    double DistanceSqr(const Point &point) const {
        return (x - point.x) * (x - point.x) + (y - point.y) * (y - point.y);
    }

    double x, y;
    IndexType id;
};

///////////////////////////////
std::mt19937 mt(228);

//////////////////////////////


struct PointsSpan {
    PointsSpan(const IndexType *ptr, IndexType sz) : ptr_(ptr), size_(sz) {
    }

    const IndexType &operator[](IndexType i) const {
        assert(i < size_);
        return ptr_[i];
    }

    IndexType Size() const {
        return size_;
    }

private:
    const IndexType *ptr_;
    IndexType size_;
};


template<typename Val, typename Index, typename Comp>
struct RelMin {
    RelMin() : first_time_(true) {}

    void Relax(Val val, Index id) {
        if (first_time_ || comp(val, val_)) {
            first_time_ = false;
            val_ = val;
            id_ = id;
        }
    }

    auto GetValue() const {
        return val_;
    }

    auto GetIndex() const {
        return id_;
    }

private:
    bool first_time_;
    Comp comp;
    Val val_;
    Index id_;
};


struct LitleSet {
    LitleSet(int cap) : cap_(cap) {
        st_.reserve(cap);
    }

    void Insert(double val, IndexType index) {
        if (st_.size() < cap_) {
            st_.emplace_back(val, index);
            Up();
        } else {
            if (st_.back().first > val) {
                st_.back().first = val;
                st_.back().second = index;
                Up();
            }
        }
    }

    auto Size() const {
        return st_.size();
    }

    std::vector<IndexType> GetIndexes() {
        std::vector<IndexType> indexes;
        for (auto &el : st_) {
            indexes.push_back(el.second);
        }
        return indexes;
    }

private:
    void Up() {
        assert(st_.size());
        int cur = st_.size() - 1;
        while (cur) {
            if (st_[cur].first < st_[cur - 1].first) {
                swap(st_[cur], st_[cur - 1]);
            } else {
                break;
            }
            cur--;
        }
    }

    int cap_;
    std::vector<std::pair<double, IndexType>> st_;
};


class SophisticatedPointsStorage {
public:
    SophisticatedPointsStorage(std::vector<Point> &&points) : points_(std::move(points)) {
        for (int i = 1; i < points_.size(); i++) {
            assert(points_[i - 1].id < points_[i].id);
        }
        CalcGreedyPath();
    }

    IndexType Size() const {
        return points_.size();
    }

    void CalcGreedyPath() {
        size_t n = Size();
        std::uniform_int_distribution<size_t> ui(0, Size() - 1);
        greedy_path_.resize(n);
        for (size_t i = 0; i < Size(); i++) {
            greedy_path_[i] = i;
        }
        size_t start = std::min_element(points_.begin(), points_.end(), [](const auto& el1, const auto& el2) {
            return el1.x + el1.y < el2.x + el2.y;
        }) - points_.begin();

        std::swap(greedy_path_[start], greedy_path_[0]);
        double len = 0;
        for (size_t i = 0; i < n - 1; i++) {
            size_t best_id = i + 1;
            double best_dist = GetDistanceSqr(greedy_path_[i], greedy_path_[best_id]);
            for (size_t j = i + 2; j < n; j++) {
                auto cur_dist = GetDistanceSqr(greedy_path_[i], greedy_path_[j]);
                if (best_dist > cur_dist) {
                    best_dist = cur_dist;
                    best_id = j;
                }
            }
            len += sqrtf(best_dist);
            std::swap(greedy_path_[i + 1], greedy_path_[best_id]);

        }
        len += GetDistance(greedy_path_[0], greedy_path_.back());
        greedy_len_ = len;
    }

    auto GetGreedyPath() const {
        return greedy_path_;
    }

    void PrecalcKClosest(IndexType k) {
        k_ = k;
        assert(k < points_.size());
        table_.resize(k * points_.size());
        for (IndexType i = 0; i < points_.size(); i++) {
            auto cur_v = greedy_path_[i];
            LitleSet st(k_);
            auto perform_j = [&](IndexType j) {
                if (cur_v != j) {
                    auto cur_dist = GetDistanceSqr(cur_v, j);
                    st.Insert(cur_dist, j);
                }
            };

            IndexType cur_l = i;
            IndexType cur_r = i;

            auto plus_1 = [&](IndexType id) {
                if (id + 1 == points_.size()) {
                    return 0;
                }
                return id + 1;
            };

            auto minus_1 = [&](IndexType id) {
                if (id == 0) {
                    return (IndexType) points_.size() - 1;
                }
                return id - 1;
            };
            for (int iter = 0; iter < points_.size() - 1; iter++) {
                if (iter & 1) {
                    cur_l = minus_1(cur_l);
                    perform_j(greedy_path_[cur_l]);
                } else {
                    cur_r = plus_1(cur_r);
                    perform_j(greedy_path_[cur_r]);
                }
            }
            assert(st.Size() == k_);
            size_t cur = k_ * cur_v;
            auto indexes = st.GetIndexes();
            for (auto &el : indexes) {
                table_[cur] = el;
                cur++;
            }
        }
    }

    double GetDistance(IndexType id1, IndexType id2) const {
        return points_[id1].Distance(points_[id2]);
    }

    double GetDistanceSqr(IndexType id1, IndexType id2) const {
        return points_[id1].DistanceSqr(points_[id2]);
    }

    PointsSpan GetClosestPoints(IndexType id) {
        assert(k_ != 0);
        return PointsSpan(&table_[id * k_], k_);
    }

private:
    double greedy_len_;
    std::vector<IndexType> greedy_path_;
    size_t k_{0};
    std::vector<Point> points_;
    std::vector<IndexType> table_;
};

void Dfs(int v, std::vector<bool> &used, const std::vector<std::vector<int>> &graph, std::vector<IndexType> &trip) {
    trip.push_back(v);
    used[v] = true;
    for (auto el : graph[v]) {
        if (!used[el]) {
            Dfs(el, used, graph, trip);
        }
    }
}

auto GetInsertionBest(SophisticatedPointsStorage& sps) {
    std::vector<IndexType> res;
    res.push_back(0);
    res.push_back(1);
    for (int i = 2; i < sps.Size(); i++) {
        RelMin<double, int, std::less<double>> rl;
        for (int j = 0; j < res.size(); j++) {
            int l = res[j];
            int r = (j + 1);
            if (r >= res.size()) {
                r -= res.size();
            }
            r = res[r];
            rl.Relax(sps.GetDistance(l, i) + sps.GetDistance(r, i) - sps.GetDistance(l, r), j + 1);
        }
        res.insert(res.begin() + rl.GetIndex(), i);
    }
    double len = 0;
    for (int i = 0; i < res.size(); i++) {
        len += sps.GetDistance(res[i], res[(i + 1) % res.size()]);
    }
    assert(res.size() == sps.Size());
    return res;
}

struct FastTripController {
    FastTripController(std::vector<IndexType> indexes, SophisticatedPointsStorage &sps) : sps_(sps), fa(indexes) {
        len_ = 0;
        for (int i = 1; i < indexes.size(); i++) {
            len_ += sps_.GetDistance(indexes[i - 1], indexes[i]);
        }
        len_ += sps_.GetDistance(indexes[0], indexes.back());
    }

    int Next(int val) {
        return fa.Next(val);
    }

    int Prev(int val) {
        return fa.Prev(val);
    }

    auto GetFinal() {
        return fa.Traverse();
    }

    bool FlipIfNothingBetween(int t1, int t2, int t3, int t4) {
        bool res = fa.Reverse2Opt(t1, t2, t3, t4);
        if (res) {
            double diff = -sps_.GetDistance(t1, t2) + sps_.GetDistance(t2, t3) - sps_.GetDistance(t3, t4) +
                          sps_.GetDistance(t4, t1);
            len_ += diff;
            diffs.push_back(diff);
        }
        return res;
    }

    double GetLen() {
        return len_;
    }

    void Commit() {
        fa.Commit();
        diffs.clear();
    }

    bool Empty() {
        return fa.Empty();
    }

    void Revert() {
        fa.Revert();
        len_ -= diffs.back();
        diffs.pop_back();
    }

private:
    double len_{0};
    std::vector<double> diffs;
    SophisticatedPointsStorage &sps_;
    FlippingArray fa;
};

int kFind = 10;

struct MaintainingState {
    IndexType t3;
    IndexType t4;
    double new_sum;
};


struct SimulateAnnealing {
    SimulateAnnealing(double temp, int per) : temp_(temp), per_(per) {}

    bool AcceptJump(double delta_len) {
        cnt_++;
        if (cnt_ % per_ == 0) {
            cnt_ = 0;
            ModifyTemp();
        }
        if (delta_len < -0.01) {
            return true;
        }
        if (temp_ < 0.2) {
            return false;
        }
        std::uniform_real_distribution<> rl(0., 1.);

        if (delta_len / temp_ > 10) {
            return false;
        }
        return rl(mt) < exp(-(delta_len) / temp_);
    }

    void Reset() {
        temp_ = 0;
        cnt_ = 0;
    }

    void ModifyTemp() {
        if (temp_ > 0.2) {
            temp_ *= 0.95;
        }
    }

    void SetTemp(double temp) {
        temp_ = temp;
    }

    void SetPer(int per) {
        per_ = per;
    }

    int cnt_{0};
    int per_;
    double temp_;
} sa(0, 1000);


bool GoInside(int t1, int t2, double sum_overall, std::set<int> &all_in_opt, FastTripController &tc,
              SophisticatedPointsStorage &sps, int cnt = 2) {
    if (cnt == kFind) {
        return false;
    }
    auto comp = [&](const MaintainingState &st1, const MaintainingState &st2) {
        return st1.new_sum < st2.new_sum;
    };
    std::set<MaintainingState, decltype(comp)> states(comp);
    auto span = sps.GetClosestPoints(t2);
    for (int j = 0; j < span.Size(); j++) {
        if (all_in_opt.count(span[j])) {
            continue;
        }
        IndexType t3 = span[j];
        if ((j & 1) == 0) {
            timer.FinishCPU();
            if (timer.TimeInSec() >= 9.5) {
                timer.StartCPU();
                return false;
            }
            timer.StartCPU();
        }
        for (IndexType t4 : {tc.Next(t3), tc.Prev(t3)}) {
            if (all_in_opt.count(t4) || t3 == t4) {
                continue;
            }

            auto diff = sps.GetDistance(t2, t3);
            if (diff + sum_overall < 0) {
                if (tc.FlipIfNothingBetween(t1, t2, t3, t4)) {
                    auto new_sum = sum_overall + diff - sps.GetDistance(t3, t4);
                    auto real_sum = new_sum + sps.GetDistance(t4, t1);
                    if (sa.AcceptJump(real_sum)) {
                        tc.Commit();
                        return true;
                    }

                    states.insert({t3, t4, new_sum});
                    tc.Revert();

                }
            }
        }
    }

    for (auto& state : states) {
        all_in_opt.insert(state.t3);
        all_in_opt.insert(state.t4);
        assert(tc.FlipIfNothingBetween(t1, t2, state.t3, state.t4));
        if (GoInside(t1, state.t4, state.new_sum, all_in_opt, tc, sps, cnt + 2)) {
            return true;
        }
        tc.Revert();
        all_in_opt.erase(state.t3);
        all_in_opt.erase(state.t4);

        timer.FinishCPU();
        if (timer.TimeInSec() >= 9.5) {
            timer.StartCPU();
            return false;
        }
        timer.StartCPU();
    }

    return false;
}

auto ApplyLiKern(std::vector<IndexType> initial, SophisticatedPointsStorage &sps) {
    int n = sps.Size();

    FastTripController tc(initial, sps);
    auto cur_len = tc.GetLen();
    RelMin<double, std::vector<IndexType>, std::less<double>> rl;
    std::vector<int> vertexes_order;
    for (int i = 0; i < n; i++) {
        vertexes_order.push_back(i);
    }
    timer.FinishCPU();
    for (int iter = 0; iter < 10000; iter++) {
        timer.StartCPU();
        std::shuffle(vertexes_order.begin(), vertexes_order.end(), mt);
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            auto t1 = vertexes_order[i];
            try {
                for (auto t2 : {tc.Next(t1), tc.Prev(t1)}) {
                    auto sum_overall = -sps.GetDistance(t1, t2);
                    std::set<int> st{t1, t2};
                    if (GoInside(t1, t2, sum_overall, st, tc, sps)) {
                        cnt++;
                        throw 1;
                    }
                }
            } catch (...) {
            }
        }
        if (!cnt && mt() % 3 == 0) {
            if (kFind <= 20) {
                kFind += 2;
            }
        }
        if (iter % 5 == 0) {
            sa.SetTemp(2 + mt() % 400);
            sa.SetPer(2 + mt() % 400);
        }
        rl.Relax(tc.GetLen(), tc.GetFinal());
        timer.FinishCPU();
        if (timer.TimeInSec() >= 9.5) {
            break;
        }
    }
    if (sps.Size() == 38) {
        assert(rl.GetValue() <= 6660.);
    }
    if (sps.Size() == 194) {
        assert(rl.GetValue() <= 9450);
    }
    if (sps.Size() == 980) {
        assert(rl.GetValue() <= 12000);
    }
    if (sps.Size() == 7146) {
        assert(rl.GetValue() <= 180000);
    }
    if (sps.Size() == 16862) {
        assert(rl.GetValue() <= 578000);
    }
    return rl.GetIndex();
}


void PrintAnswer(std::ostream &out, const SophisticatedPointsStorage &sps,
                 const std::vector<IndexType> &points_perm) {
    int64_t check_sum = 0;
    for (auto &el : points_perm) {
        check_sum += el;
    }
    assert(check_sum == points_perm.size() * 1ll * (points_perm.size() - 1) / 2);

    double len = 0;
    for (int i = 1; i < points_perm.size(); i++) {
        len += sps.GetDistance(points_perm[i - 1], points_perm[i]);
    }
    if (points_perm.size() > 2) {
        len += sps.GetDistance(points_perm[0], points_perm.back());
    }
    out.setf(std::ios::fixed);
    out.precision(20);
    out << len << std::endl;
    for (auto &point_id : points_perm) {
        out << point_id + 1 << " ";
    }
    out << std::endl;
}


auto ReadInput(std::istream& in) {
    size_t n;
    in >> n;
    std::vector<Point> points(n);
    IndexType id = 0;
    for (auto &el : points) {
        in >> el.x >> el.y;
        el.id = id;
        id++;
        assert(id > 0);
    }

    return points;
}

auto GetMstTrip(SophisticatedPointsStorage &sps) {
    int n = sps.Size();
    std::vector<RelMin<double, IndexType, std::less<double>>> mins(n);
    std::vector<bool> used(n, false);

    std::vector<std::vector<int>> graph(n);
    used[0] = true;
    for (int i = 1; i < n; i++) {
        mins[i].Relax(sps.GetDistance(i, 0), 0);
    }
    double len = 0;
    for (int i = 1; i < n; i++) {
        RelMin<double, std::pair<IndexType, IndexType>, std::less<double>> cur_edge;
        for (int j = 0; j < n; j++) {
            if (!used[j]) {
                cur_edge.Relax(mins[j].GetValue(), {j, mins[j].GetIndex()});
            }
        }
        int from = cur_edge.GetIndex().first;
        int to = cur_edge.GetIndex().second;
        graph[from].push_back(to);
        graph[to].push_back(from);
        len += sps.GetDistance(from, to);
        used[from] = true;

        for (int j = 0; j < n; j++) {
            if (!used[j]) {
                mins[j].Relax(sps.GetDistance(j, from), from);
            }
        }
    }
//    std::cerr << "Mst size : " << len << std::endl;
    used.assign(used.size(), false);
    std::vector<IndexType> trip;
    Dfs(0, used, graph, trip);
    return trip;
}

void SolveForJudge() {
    std::ios_base::sync_with_stdio(0);
    std::cin.tie(0);
    timer.Reset();
    timer.StartCPU();
    SophisticatedPointsStorage sps(ReadInput(std::cin));

    sps.PrecalcKClosest(7);
    auto greedy = GetMstTrip(sps);

    greedy = ApplyLiKern(greedy, sps);
    PrintAnswer(std::cout, sps, greedy);
    timer.FinishCPU();
}

int main() {
    SolveForJudge();
    return 0;
}
